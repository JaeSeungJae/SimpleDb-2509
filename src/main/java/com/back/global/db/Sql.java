package com.back.global.db;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

public class Sql {
    private final SimpleDb simpleDb;
    private final StringBuilder sqlQuery = new StringBuilder();
    private final List<Object> parameters = new ArrayList<>();

    public Sql(SimpleDb simpleDb) {
        this.simpleDb = simpleDb;
    }

    public Sql append(String queryPart, Object... values) {
        sqlQuery.append(queryPart).append(" ");

        parameters.addAll(Arrays.asList(values));

        return this;
    }

    public Sql appendIn(String queryPart, Object... values) {
        int idx = queryPart.indexOf("?");

        // (?, ?, ?, ...)
        String placeholders = Arrays.stream(values)
                .map(v -> "?")
                .collect(Collectors.joining(", "));

        sqlQuery.append(queryPart, 0, idx)
                .append(placeholders)
                .append(queryPart.substring(idx + 1))
                .append(" ");

        Collections.addAll(parameters, values);

        return this;
    }

    public long insert() {
        return executeCommonQuery(sqlQuery.toString(), parameters, Statement.RETURN_GENERATED_KEYS, pstmt -> {
            pstmt.executeUpdate();
            try (ResultSet rs = pstmt.getGeneratedKeys()) {
                return rs.next() ? rs.getLong(1) : -1L;
            }
        });
    }

    public int update() {
        return executeCommonQuery(sqlQuery.toString(), parameters, Statement.NO_GENERATED_KEYS, PreparedStatement::executeUpdate);
    }

    public int delete() {
        return executeCommonQuery(sqlQuery.toString(), parameters, Statement.NO_GENERATED_KEYS, PreparedStatement::executeUpdate);
    }

    public List<Map<String, Object>> selectRows() {
        return executeSelectList(sqlQuery.toString(), parameters,
                rs -> mapRowToMap(rs, rs.getMetaData(), rs.getMetaData().getColumnCount()));
    }

    public Map<String, Object> selectRow() {
        return executeSelectOne(sqlQuery.toString(), parameters,
                rs -> mapRowToMap(rs, rs.getMetaData(), rs.getMetaData().getColumnCount()));
    }

    public <T> List<T> selectRows(Class<T> clazz) {
        return executeSelectList(sqlQuery.toString(), parameters,
                rs -> mapRowToObject(clazz, rs, rs.getMetaData(), rs.getMetaData().getColumnCount()));
    }

    public <T> T selectRow(Class<T> clazz) {
        return executeSelectOne(sqlQuery.toString(), parameters,
                rs -> mapRowToObject(clazz, rs, rs.getMetaData(), rs.getMetaData().getColumnCount()));
    }

    public LocalDateTime selectDatetime() {
        return executeSelectQuery(sqlQuery.toString(), parameters, rs -> {
            if (!rs.next()) return null;

            Timestamp ts = rs.getTimestamp(1);
            return ts != null ? ts.toLocalDateTime() : null;
        });
    }

    public Long selectLong() {
        return executeSelectQuery(sqlQuery.toString(), parameters,
                rs -> rs.next() ? rs.getLong(1) : null);
    }

    public String selectString() {
        return executeSelectQuery(sqlQuery.toString(), parameters,
                rs -> rs.next() ? rs.getString(1) : null);
    }

    public Boolean selectBoolean() {
        return executeSelectQuery(sqlQuery.toString(), parameters,
                rs -> rs.next() ? rs.getBoolean(1) : null);
    }

    public List<Long> selectLongs() {
        return executeSelectQuery(sqlQuery.toString(), parameters, rs -> {
            List<Long> results = new ArrayList<>();
            while (rs.next()) {
                results.add(rs.getLong(1));
            }
            return results;
        });
    }

    @FunctionalInterface
    public interface CheckedFunction<T, R> {
        R apply(T t) throws SQLException, ReflectiveOperationException;
    }

    private <R> R executeCommonQuery(String query, List<Object> params, int autoGeneratedKeys, CheckedFunction<PreparedStatement, R> callback) {
        try (Connection conn = simpleDb.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(query, autoGeneratedKeys)) {
            bindParams(pstmt, params);
            return callback.apply(pstmt);
        } catch (SQLException e) {
            throw new RuntimeException("SQL문 실행 실패: " + query, e);
        } catch (ReflectiveOperationException e) {
            throw new RuntimeException(e);
        }
    }

    private <R> R executeSelectQuery(String query, List<Object> params, CheckedFunction<ResultSet, R> callback) {
        return executeCommonQuery(query, params, ResultSet.TYPE_FORWARD_ONLY, pstmt -> {
            try (ResultSet rs = pstmt.executeQuery()) {
                return callback.apply(rs);
            }
        });
    }

    private void bindParams(PreparedStatement pstmt, List<Object> params) throws SQLException {
        for (int i = 0; i < params.size(); i++) {
            pstmt.setObject(i + 1, params.get(i));
        }
    }

    @FunctionalInterface
    public interface RowMapper<T> {
        T mapRow(ResultSet rs) throws SQLException, ReflectiveOperationException;
    }

    private <T> List<T> executeSelectList(String query, List<Object> params, RowMapper<T> mapper) {
        return executeSelectQuery(query, params, rs -> {
            List<T> results = new ArrayList<>();
            while (rs.next()) {
                results.add(mapper.mapRow(rs));
            }
            return results;
        });
    }

    private <T> T executeSelectOne(String query, List<Object> params, RowMapper<T> mapper) {
        return executeSelectQuery(query, params, rs -> {
            if (rs.next()) return mapper.mapRow(rs);
            return null;
        });
    }

    private Map<String, Object> mapRowToMap(ResultSet rs, ResultSetMetaData metaData, int columnCount) throws SQLException {
        Map<String, Object> row = new HashMap<>();

        for (int i = 1; i <= columnCount; i++) {
            String columnName = metaData.getColumnLabel(i);
            Object value = rs.getObject(i);
            row.put(columnName, value);
        }

        return row;
    }

    private <T> T mapRowToObject(Class<T> clazz, ResultSet rs, ResultSetMetaData metaData, int columnCount) throws SQLException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        T obj = clazz.getDeclaredConstructor().newInstance();

        for (int i = 1; i <= columnCount; i++) {
            String columnName = metaData.getColumnLabel(i);
            Object value = rs.getObject(i);

            Field field;
            try {
                field = clazz.getDeclaredField(columnName);
            } catch (NoSuchFieldException e) {
                continue;
            }
            field.setAccessible(true);

            switch (value) {
                case Timestamp ts when field.getType().equals(LocalDateTime.class) ->
                        field.set(obj, ts.toLocalDateTime());
                case Boolean b when field.getType().equals(boolean.class) -> field.set(obj, b);
                default -> field.set(obj, value);
            }
        }
        return obj;
    }
}
